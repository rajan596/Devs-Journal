
## General Concepts

- Understand JVM:
    - TBD


## Streams in Java
- Input from terminal : System.in is used to take input from terminal
```java
Scanner sc = new Scanner(System.in); // As System.in alone cant read inputs from terminal
int no = sc.nextInt();
```
- System class in Java
```java
public final class System { 
    public static final InputStream in = null;
    public static final PrintStream out = null;
    public static final PrintStream err = null;
}
```
- byte data can be read and written using InputStream and OutputStream
```java
// Source: GFG
byte[] data = {(byte) 0xe0, 0x4f, (byte) 0xd0, 0x20, (byte) 0xea};
OutputStream os = new FileOutputStream("data.bin");
os.write(data);
os.close();

// Reading binary data from a file using InputStream
InputStream is = new FileInputStream("data.bin");
byte[] newData = new byte[5];
is.read(newData);
is.close();
```
- File Streams
```java
class FileOutputStream extends OutputStream{};

try {
    File file = new File("/Users/rajan/Documents/code/practice/src/main/java/com/adobe/java/abc.txt");
    FileOutputStream fileOutputStream = new FileOutputStream(file);
    String message = "Hello from Java !!";
    fileOutputStream.write(message.getBytes(StandardCharsets.UTF_8));
    fileOutputStream.close();

    FileInputStream fileInputStream = new FileInputStream(file);
    byte[] bytes = new byte[1000];
    fileInputStream.read(bytes);
    System.out.println(new String(bytes));
    fileInputStream.close();
} catch (IOException ex) {
    System.out.println(ex.getMessage());
}
```
- BufferedInputStream and BufferedOutputStream
    - Used to buffer input and output
    - Can increase performance when dealing with large amount of data
```java
BufferedInputStream(InputStream inp);
BufferedOutputStream(OutputStream output);
```


- transient keyword
    - JVM do not save original value of variable marked with transient in file at the time of Serialisation but rather stores default value
- Jagged array
    - Each rows can have varyinf col size
```java
int[][] Arr = new int[][] {
    {1, 2, 8}, 
    {7, 5}, 
    {6, 7, 2, 6}
};

public class JaggedArrayExample {
    public static void main(String[] args) {
        // Declare and initialize the jagged array
        int[][] jaggedArray = new int[3][];
        jaggedArray[0] = new int[2];
        jaggedArray[1] = new int[3];
        jaggedArray[2] = new int[4];

        // Assign values to the elements
        jaggedArray[0][0] = 1;
        jaggedArray[0][1] = 2;
        jaggedArray[1][0] = 3;
        jaggedArray[1][1] = 4;
        jaggedArray[1][2] = 5;
        jaggedArray[2][0] = 6;
        jaggedArray[2][1] = 7;
        jaggedArray[2][2] = 8;
        jaggedArray[2][3] = 9;

        // Print the jagged array
        for (int i = 0; i < jaggedArray.length; i++) {
            for (int j = 0; j < jaggedArray[i].length; j++) {
                System.out.print(jaggedArray[i][j] + " ");
            }
            System.out.println();
        }
    }
}
- **Volatile**
    -  Volatile keywords in Java can only be applied to individual variables but not to arrays or collections.
    - The value of the Variable is always read from and written to the main memory when it is defined as volatile rather than being cached in a thread’s local memory. This makes it easier to make sure that all threads that access the variable can see changes made to it.
- new vs newInstance()
    - If specific type of object is decided at runtime then new can't be used. Rather newInstance needs to be created.
- Type of cunstructors in Java
    - Default constructor : No argument <Generated by Compiler>
    - Parameterised : Declared by User
- Marker Interface
    - A marker interface is an empty interface, meaning it doesn't contain any methods or constants. It's primarily used to provide runtime type information about an object, allowing the JVM to perform certain actions based on this information.
    - Marker interfaces allow type identification at runtime using the instanceof operator. This makes it easy to determine if an object has a specific capability or belongs to a particular category.
    - Examples: Serializable, Cloneable, Remote interfaces
    - Marker interfaces are a simple yet powerful tool in Java for **adding metadata to classes**. They enhance type identification, code readability, and framework integration, although annotations are sometimes preferred for more complex scenarios.
```java
// Marker interface
public interface Auditable {
    // No methods
}

// A class implementing the marker interface
public class User implements Auditable {
    private String name;
    private String email;
    
    // Getters and Setters
}

// Another class not implementing the marker interface
public class Product {
    private String productName;
    private double price;
    
    // Getters and Setters
}

// Using the marker interface to check if an object is Auditable
public class MarkerInterfaceExample {
    public static void main(String[] args) {
        User user = new User();
        Product product = new Product();
        
        if (user instanceof Auditable) {
            System.out.println("User is auditable.");
        } else {
            System.out.println("User is not auditable.");
        }
        
        if (product instanceof Auditable) {
            System.out.println("Product is auditable.");
        } else {
            System.out.println("Product is not auditable.");
        }
    }
}

```
- Aggregation
    - Has-a Relationship 
    - Represent it by using the filled diamond.
    - Objects are independent of each other.
- Composition 
    - Part-of Relationship (Other entity cant exists without parent entity) Like heart withour body
    - Objects are dependent on each other


```
- Difference between >> and >>>
```java
int a = -8;  // Binary representation: 11111111 11111111 11111111 11111000
int result = a >> 2;  // Result: 11111111 11111111 11111111 11111110 (which is -2)

int a = -8;  // Binary representation: 11111111 11111111 11111111 11111000
int result = a >>> 2;  // Result: 00111111 11111111 11111111 11111110 (which is a large positive number)

// Use >> when you need to preserve the sign of the number during the shift.
// Use >>> when you do not want to preserve the sign and want to fill the higher-order bits with 0s.
```

- Generics:
    - Implementation of class irrespective of data type like….Stack of various data types.
    - The generic information is lost in runtime. There is no runtime equivalent of a Creator<String>.class. You could create a type between Creator and StringCreator which fixes the generic type
- Map: Map is an interface for storing key value pairs
    - LikedHashMap: Maintains order of insertion of elements
    - TreeMap: maintains sorting order based on natural keys or comparator provided on constructor
- Java is an interpreted language that is why it is slower than compiled languages, e.g., C, C++, etc.
- Java uses both compiler and interpreter. Java source code is converted into bytecode at compilation time. The interpreter executes this bytecode at runtime and produces output. Java is interpreted that is why it is platform-independent.
- Java doesn't support default arguments like C++.
- Java has 2 bytes for char. It follows unicode rather than ASCII 
- The static variable gets memory only once in the class area at the time of class loading.
- Java provides a Constructor class which can be used to get the internal information of a constructor in the class. It is found in the java.lang.reflect package
- You can have any number of main methods in a class by method overloading. But JVM calls main() method which receives string array as arguments only
- Package: collection of class, interface and sub packages
- Think of Abstract class, interface for Abstraction
- Think of access modifier, packages, getter setter methods for Encapsulation
- Multi threading
- Implementation of Map in Java
- How sort is implemented in Java
- Futures in Java
    - Used for async processing
- Generics
    - Provides compile time type safety and any error if there
    - Type errors get detected at compile time rather than at run time when generics are not used.
Example
    - It's important to realize that generic type information is only available to the compiler, not the JVM. In other words, type erasure means that generic type information is not available to the JVM at runtime, only compile time.
    - Type Wildcards
        - List<? extends Number> means that the given list contains objects of some unknown type which extends the Number class.
        - The use of wildcards above adds flexibility since there is not any inheritance relationship between any two parameterized types with concrete type as type argument. Neither List<Number> nor List<Integer> is a subtype of the other; even though Integer is a subtype of Number.
        - To specify the lower bounding class of a type wildcard, the super keyword is used. This keyword indicates that the type argument is a supertype of the bounding class. So, List<? super Number> could represent List<Number> or List<Object>    
- Sets in Java
    - LinkedHashSet : Maintains hash table of all unique elements
        - Allows null values
        - Maintains insertion order
- Enum class
    - Special class that represents group of constants (like final)
    - Every enum variable is implicitly public static final
    - Enum can not extend any class since it implicitly extends Enum class
    - Enum can implement many interfaces
    - toString() can be used to get enum name in string
- var keyword
    - When the type of the variable can be inferred by the compiler in that case we can use var keyword
    - Right hand side should be sufficient to indicate to the compiler which type variable is this.
    - Assignment is needed while declaring variables. Like var a = 10; works while var b; doesn’t work.
If we want to assign instance type to reference type like List<Integer> list = new ArrayList<Integer>(); in this case var can’t be used.
var can’t be a class variable. It must be a local variable.
var can’t be a part of method arguments.
var is not a reserved word 
Lambda
Enables functional programming
Coincide code in some scenarios
Enables support for parallel processing
Why do we need lambda ? It offer more less, readable, maintainable code
Do not write a return keyword for one liner lambda functions without {}. It's invalid.
Automatic type inference happens if inline lambda is passed and receiver is Interface reference.
Interface requirement to use for lambas: Only one abstract method matching input and output type
If in future someone tries to add a new abstract method in the lambda interface then code will stop working. So, we need some way to differentiate class Interface and functional Interface.
For this purpose FunctionalInterface annotation can be used. Its optional but good to have annotation
Lambda can be handy while implementing a comparator interface. Code is way too less.
One option to handle exceptions can be to have a wrapper lambda which has a try catch block.
You can not use this keyword in lambda expressions under the inside static method.
Closures: 
When using any local variable in any other inner class methods, Java restricts that variable to either be declare as final or  
From Java8 we can write interfaces which can have implementation methods.
When should we throw exceptions in Java ?
When there is contract violation. If code behaves as expected then exceptions should be avoided.
Reflections
Kind of meta programming
We get all details of class, its fields, its methods. Access modifier can be altered. Method can be invoked using its name.


Working with JSON
Jackson is one of the most popular Java JSON library. Gson is also amongs top.
You can read JSON tree in JsonNode and then call get or path method to fetch child nodes
JsonPointer can be used to point to specific single object in Json
JsonObject library can also come handly while dealing with JSON based structure
References: https://www.twilio.com/blog/java-json-with-jackson

For DS/Algo questions

To find maximum use
Math.max(5, 10);
Integer to string conversion
Integer.toString(67)
Integer.MAX_VALUE
String..
String s = “abcd”;
s.charAt(4);
Hashmap in Java
Map< Integer, List<Integer> > graph = new HashMap<>();
graph.getOrDefault(3,null);
graph.containsKey(5);
Iterate map..
Map.Entry<Character, Integer> mp: tmpMap.entrySet()
Copy paste map: map.putAll(otherMap);
map.size()
Arrays…
int arr[] = new int[5];
int arr[] = new int[]{1,2,3,4,5};
int arr[] = {1,2,3,4,5}; 
For prefix sum in array: Arrays.parallelPrefix(array, Integer::sum);
Arrays.fill(array , -1);
Char c[] = “abcd”.toCharArray();
String s = new String(char_arr);
long long_val =  Long.parseLong(“5968496”);
Array of pairs : Need to create custom Pair class since there is no such class in Java
2D array: int arr[][] = new int[3][4];
Cloning an array: int newark[] = arr.clone()
1D array -> clone -> deep copy
Multi dimensional array -> clone -> shallow copy


Dynamic array
ArrayList<>()
Sorting…
Inbuilt Arrays.sort(arrName) method uses Dual-Pivot Quicksort algorithm
Arrays is a class and has static method sort defined under java.util.Arrays
Custom sorting: need a comparator 

o1 -> left element
o2 -> right element
Return 1 if you want to swap both element else -1 or 0
Pair…
Pair p1 = new Pair(3,4);
Pair<Integer, String> p2 = new Pair<Integer, String>( 5 , “hey”);
Get key: p2.getKey()
Get value: p2.getValue()
Stack..
Stack<Integer> stack = new Stack<Integer>();
stack.push(4);
stack.pop();
stack.empty();
stack.peek();
Queue

Queue<Integer> q = new LinkedList<>();
q.add(4);
Integer removedElement = q.remove();
Integer viewFrontElement = q.peek();
q.size();
Priority Queue
PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>();
pQueue.add(10);
pQueue.peek() // Get top element
pQueue.poll() // remove and get top element
Priority queue comparator 

Set
Set<TreeNode> mSet = new HashSet<TreeNode>();


Time 
System.currentTimeMillis() from java.lang.System gives time in mS from 1970
Futures
Can be used for async tasks. Simply put them in future and then get the result using get() method
While calling get() method it blocks the flow and wait for the task to complete and then returns the result.
Future can be cancelled.


## Garbage Collector

- *Garbage collector when executes stops complete JVM execution*
